---
description: Form handling with React Hook Form, Zod validation, and Server Actions
globs: **/*.{js,ts,jsx,tsx}
alwaysApply: false
---
# Form Handling

## Overview

This project uses a standardized approach to form handling:

- **React Hook Form** for form state management
- **Zod** for schema validation (both client and server)
- **shadcn/ui Form components** from `mingster.backbone`
- **Server Actions** for form submission
- **Toast notifications** from `mingster.backbone` for feedback

## Basic Form Pattern

### 1. Define Validation Schema

Create a Zod schema for validation (shared between client and server):

```typescript
// actions/sysAdmin/systemMessage/update-system-message.validation.ts
import { z } from "zod/v4";

export const updateSystemMessageSchema = z.object({
  id: z.string(),
  message: z.string().min(1, "Message is required"),
  localeId: z.string().optional(),
  published: z.boolean().default(false),
});

export type UpdateSystemMessageInput = z.infer<typeof updateSystemMessageSchema>;
```

### 2. Create Server Action

```typescript
// actions/sysAdmin/systemMessage/update-system-message.ts
"use server";

import { adminActionClient } from "@/lib/safe-action";
import { updateSystemMessageSchema } from "./update-system-message.validation";
import prismadb from "@/lib/prismadb";

export const updateSystemMessageAction = adminActionClient
  .metadata({ name: "updateSystemMessage" })
  .schema(updateSystemMessageSchema)
  .action(async ({ parsedInput }) => {
    const { id, ...data } = parsedInput;
    
    if (id === "new") {
      const result = await prismadb.systemMessage.create({
        data: { ...data },
      });
      return { success: true, data: result };
    }
    
    const result = await prismadb.systemMessage.update({
      where: { id },
      data,
    });
    
    return { success: true, data: result };
  });
```

### 3. Create Form Component

```tsx
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
  Button,
  Input,
  Textarea,
  Switch,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  toastSuccess,
  toastError,
} from "mingster.backbone";
import { updateSystemMessageAction } from "@/actions/sysAdmin/systemMessage/update-system-message";
import {
  type UpdateSystemMessageInput,
  updateSystemMessageSchema,
} from "@/actions/sysAdmin/systemMessage/update-system-message.validation";

interface Props {
  item: UpdateSystemMessageInput;
  onUpdated?: (newValue: UpdateSystemMessageInput) => void;
}

export function EditSystemMessage({ item, onUpdated }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const [loading, setLoading] = useState(false);

  const form = useForm<UpdateSystemMessageInput>({
    resolver: zodResolver(updateSystemMessageSchema),
    defaultValues: item,
    mode: "onChange", // Validate on change
  });

  async function onSubmit(data: UpdateSystemMessageInput) {
    setLoading(true);
    
    const result = await updateSystemMessageAction(data);
    
    if (result?.serverError) {
      toastError({ description: result.serverError });
      setLoading(false);
      return;
    }

    toastSuccess({ description: "Saved successfully!" });
    setLoading(false);
    setIsOpen(false);
    
    onUpdated?.(data);
  }

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        <Button>Edit</Button>
      </DialogTrigger>

      <DialogContent>
        <DialogHeader>
          <DialogTitle>Edit System Message</DialogTitle>
          <DialogDescription>
            Make changes to the system message.
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="message"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Message</FormLabel>
                  <FormControl>
                    <Textarea
                      placeholder="Enter message"
                      disabled={loading}
                      {...field}
                    />
                  </FormControl>
                  <FormDescription>
                    This message will be displayed to users.
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="localeId"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Locale</FormLabel>
                  <FormControl>
                    <Input {...field} disabled={loading} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="published"
              render={({ field }) => (
                <FormItem className="flex items-center justify-between rounded-lg border p-3">
                  <div>
                    <FormLabel>Published</FormLabel>
                    <FormDescription>
                      Make this message visible to users
                    </FormDescription>
                  </div>
                  <FormControl>
                    <Switch
                      checked={field.value}
                      onCheckedChange={field.onChange}
                      disabled={loading}
                    />
                  </FormControl>
                </FormItem>
              )}
            />

            <div className="flex gap-2">
              <Button 
                type="submit" 
                disabled={loading || form.formState.isSubmitting}
              >
                {loading ? "Saving..." : "Save"}
              </Button>
              <Button
                type="button"
                variant="outline"
                onClick={() => setIsOpen(false)}
                disabled={loading}
              >
                Cancel
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```

## Form Components from mingster.backbone

### All Form Imports

```tsx
import {
  // Form Context
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  useFormField,
  
  // Input Components
  Input,
  Textarea,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  Checkbox,
  RadioGroup,
  RadioGroupItem,
  Switch,
  Slider,
  Calendar,
  
  // Button
  Button,
  
  // Toast
  toastSuccess,
  toastError,
} from "mingster.backbone";
```

## Common Form Patterns

### Select Dropdown

```tsx
<FormField
  control={form.control}
  name="status"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Status</FormLabel>
      <Select onValueChange={field.onChange} defaultValue={field.value}>
        <FormControl>
          <SelectTrigger>
            <SelectValue placeholder="Select status" />
          </SelectTrigger>
        </FormControl>
        <SelectContent>
          <SelectItem value="active">Active</SelectItem>
          <SelectItem value="inactive">Inactive</SelectItem>
          <SelectItem value="pending">Pending</SelectItem>
        </SelectContent>
      </Select>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Checkbox

```tsx
<FormField
  control={form.control}
  name="acceptTerms"
  render={({ field }) => (
    <FormItem className="flex items-center space-x-2">
      <FormControl>
        <Checkbox
          checked={field.value}
          onCheckedChange={field.onChange}
        />
      </FormControl>
      <FormLabel>Accept terms and conditions</FormLabel>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Radio Group

```tsx
<FormField
  control={form.control}
  name="role"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Role</FormLabel>
      <FormControl>
        <RadioGroup
          onValueChange={field.onChange}
          defaultValue={field.value}
        >
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="admin" id="admin" />
            <Label htmlFor="admin">Admin</Label>
          </div>
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="user" id="user" />
            <Label htmlFor="user">User</Label>
          </div>
        </RadioGroup>
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Date Picker

```tsx
import { format } from "date-fns";
import { Popover, PopoverContent, PopoverTrigger } from "mingster.backbone";

<FormField
  control={form.control}
  name="date"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Date</FormLabel>
      <Popover>
        <PopoverTrigger asChild>
          <FormControl>
            <Button variant="outline">
              {field.value ? format(field.value, "PPP") : "Pick a date"}
            </Button>
          </FormControl>
        </PopoverTrigger>
        <PopoverContent>
          <Calendar
            mode="single"
            selected={field.value}
            onSelect={field.onChange}
          />
        </PopoverContent>
      </Popover>
      <FormMessage />
    </FormItem>
  )}
/>
```

## Validation Patterns

### Required Fields

```typescript
const schema = z.object({
  email: z.string().email("Invalid email address"),
  name: z.string().min(1, "Name is required"),
  age: z.number().min(18, "Must be at least 18"),
});
```

### Optional Fields

```typescript
const schema = z.object({
  email: z.string().email().optional(),
  phone: z.string().optional().or(z.literal("")),
});
```

### Custom Validation

```typescript
const schema = z.object({
  password: z.string().min(8, "Password must be at least 8 characters"),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});
```

### Conditional Validation

```typescript
const schema = z.object({
  type: z.enum(["email", "phone"]),
  email: z.string().email().optional(),
  phone: z.string().optional(),
}).refine(
  (data) => {
    if (data.type === "email") return !!data.email;
    if (data.type === "phone") return !!data.phone;
    return true;
  },
  {
    message: "Required field based on type",
  }
);
```

## Error Handling

### Display Server Errors

```tsx
async function onSubmit(data: FormInput) {
  const result = await submitFormAction(data);
      
      if (result?.serverError) {
    toastError({ description: result.serverError });
    return;
  }
  
  if (result?.validationErrors) {
    // Set field-specific errors
    Object.entries(result.validationErrors).forEach(([field, message]) => {
      form.setError(field as keyof FormInput, {
        message: message as string,
      });
    });
    return;
  }
  
  toastSuccess({ description: "Form submitted!" });
}
```

### Field-Level Errors

```tsx
<FormField
  control={form.control}
  name="email"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Email</FormLabel>
      <FormControl>
        <Input {...field} />
      </FormControl>
      <FormMessage /> {/* Shows validation error */}
    </FormItem>
  )}
/>
```

## Loading States

### Disable Form During Submission

```tsx
const [loading, setLoading] = useState(false);

<Button 
  type="submit" 
  disabled={loading || form.formState.isSubmitting}
>
  {loading ? "Saving..." : "Save"}
</Button>

<Input 
  {...field} 
  disabled={loading || form.formState.isSubmitting} 
/>
```

### Form State

```tsx
const { isDirty, isValid, isSubmitting } = form.formState;

<Button 
  type="submit" 
  disabled={!isDirty || !isValid || isSubmitting}
>
  Save Changes
</Button>
```

## Best Practices

1. **Use Zod schemas**: Define validation once, use on client and server
2. **Import from backbone**: All form components come from `mingster.backbone`
3. **Handle errors properly**: Use `toastError` and `toastSuccess`
4. **Disable during submission**: Prevent double submissions
5. **Show inline errors**: Use `<FormMessage />` for field errors
6. **Validate on change**: Use `mode: "onChange"` for real-time validation
7. **Reset after submit**: Call `form.reset()` after successful submission
8. **Type safety**: Use TypeScript with `z.infer<typeof schema>`

## Complete Example

```tsx
"use client";

import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod/v4";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  Input,
  Button,
  toastSuccess,
  toastError,
} from "mingster.backbone";
import { createUserAction } from "@/actions/user/create-user";

const userSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email"),
  age: z.number().min(18, "Must be 18 or older"),
});

type UserInput = z.infer<typeof userSchema>;

export function UserForm() {
  const form = useForm<UserInput>({
    resolver: zodResolver(userSchema),
    defaultValues: {
      name: "",
      email: "",
      age: 18,
    },
    mode: "onChange",
  });

  async function onSubmit(data: UserInput) {
    const result = await createUserAction(data);
    
    if (result?.serverError) {
      toastError({ description: result.serverError });
      return;
    }
    
    toastSuccess({ description: "User created successfully!" });
    form.reset();
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input type="email" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="age"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Age</FormLabel>
              <FormControl>
      <Input
                  type="number" 
                  {...field}
                  onChange={(e) => field.onChange(Number(e.target.value))}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <Button 
          type="submit" 
          disabled={form.formState.isSubmitting}
        >
          {form.formState.isSubmitting ? "Creating..." : "Create User"}
      </Button>
    </form>
    </Form>
  );
}
```

## Migration Notes

- **Old**: `import { Button } from "@/components/ui/button"`
- **New**: `import { Button } from "mingster.backbone"`
- **Old**: `import { toastError } from "@/components/Toast"`
- **New**: `import { toastError } from "mingster.backbone"`

All form UI components and toast notifications now come from `mingster.backbone`.
