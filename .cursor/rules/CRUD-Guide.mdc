---
name: CRUD Guide (Modern Client State Pattern)
description: Guide to managing data (CRUD operations - Create, Read, Update, Delete)
globs: ["**/*.{js,ts,jsx,tsx,mdx,css}"]
alwaysApply: true
---

# Standard CRUD Operation Pattern  (Modern Client State Pattern)

This application follows a modern pattern for managing data (CRUD operations - Create, Read, Update, Delete) in this Next.js App Router projects.

## Key Principles

- **Local State Management:** The main client component (e.g., `client-FaqCategory.tsx`) holds the data array in local state (`useState`).
- **Edit/Create Dialogs:** Edit and create forms (e.g., `edit-FaqCategory`) are rendered as modals or drawers and receive `onUpdated` callbacks from the parent.
- **Direct State Updates:** After a mutation (create, update, delete), the parent updates its local state array directly, ensuring the UI is always in sync.
- **No router.refresh for Client State:** Do **not** rely on `router.refresh()` to update client-side state. Only use it if you want to re-fetch server components.
- **Type Safety:** Always ensure new/updated items include all required fields for the state array's type.

## Structure

- Each CRUD resource has its own directory under `/*/RESOURCE_NAME`.
- The main page (e.g., @`page.tsx`) fetches data on the server and passes it to a client component.
- The client component (e.g., @`client-sysmsg.tsx`) handles displaying the data in a table, as well as client-side state for create, update, and delete operations.
- Editing and creating items is handled by a dedicated form/dialog component (e.g., @`edit-sysmsg.tsx`), which uses a modal dialog and react-hook-form for validation and submission.
- Actions (edit, delete, copy, etc.) are provided via dropdown menus and confirmation dialogs in `CellAction` function.
- Data is updated optimistically on the client after successful server actions.

## Key Conventions

1. **Server Data Fetching:**  
   Fetch all data for the resource in the main page server component and pass it as props to the client component.

2. **Client Table Component:**  
   - Receives the server data as a prop.
   - Manages local state for the data array.
   - `CellAction` function provides dropdown menus and confirmation dialogs for delete mutation.

3. **Edit/Create Dialog:**  
   - Uses a modal dialog for editing or creating items.
   - Uses react-hook-form and zod for validation.
   - Calls server actions for create/edit mutations.
   - Notifies the parent component to update local state after mutation.

4. **Actions:**  
   - Use dropdown menus for row actions (edit, delete, copy, etc.).
   - Use confirmation dialogs for destructive actions.

5. **UI Components:**  
   - Use shadcn/ui components for table, dialog, button, etc.
   - Use Suspense and Loader for async loading states.

## Example Reference

- Main CRUD page: `src/app/sysAdmin/sysmsg/page.tsx`
- Client table: `src/app/sysAdmin/sysmsg/components/client-sysmsg.tsx`
- Edit/Create dialog: `src/app/sysAdmin/sysmsg/components/edit-sysmsg.tsx`

---

**Follow this pattern for all new CRUD resources in the admin section for consistency and maintainability.**

## Example Pattern

### 1. Define/Create Type

Add the type to `src/types.d.ts`:

```typescript
export type SystemMessage = {
  id: string;
  message: string;
  localeId: string;
  published: boolean;
  createdOn?: Date;
  lastModified?: Date;
};
```

### 2. Create Server Action and Validation

Create action file: `src/actions/sysAdmin/[feature]/update-[object].ts`
Create validation file: `src/actions/sysAdmin/[feature]/update-[object].validation.ts`

See [server-action.mdc](mdc:.cursor/rules/server-action.mdc) for details.

### 3. Create Server Page (page.tsx)

```tsx
import { Suspense } from "react";
import { Loader } from "@/components/loader";
import Container from "@/components/ui/container";
import { transformBigIntToNumbers } from "@/lib/utils";
import prismadb from "@/lib/prismadb";
import { SystemMessageClient } from "./components/client-sysmsg";

export default async function SystemMessageAdminPage(props: {
  params: Promise<{ [key: string]: string }>;
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}) {
  // Fetch data on server
  const data = await prismadb.systemMessage.findMany({
    orderBy: { createdOn: "desc" },
  });
  
  // Transform BigInt to Numbers for client
  transformBigIntToNumbers(data);

  return (
    <Suspense fallback={<Loader />}>
      <Container>
        <SystemMessageClient serverData={data} />
      </Container>
    </Suspense>
  );
}
```

### 4. Client List Component (holds state)

File: `components/client-[object].tsx`

```tsx
"use client";

import { useState } from "react";
import type { ColumnDef } from "@tanstack/react-table";
import { DataTable, DataTableColumnHeader } from "@/components/data-table";
import { Heading } from "@/components/heading";
import { Separator } from "@/components/ui/separator";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { AlertModal } from "@/components/modals/alert-modal";
import { toast } from "@/components/ui/use-toast";
import { IconDots, IconCopy, IconTrash } from "@tabler/icons-react";
import type { SystemMessage } from "@/types";
import { EditSystemMessage } from "./edit-sysmsg";

interface Props {
  serverData: SystemMessage[];
}

export const SystemMessageClient: React.FC<Props> = ({ serverData }) => {
  const [data, setData] = useState<SystemMessage[]>(serverData);

  // New empty object for create
  const newMessage: SystemMessage = {
    id: "new",
    message: "",
    localeId: "",
    published: false,
  };

  // State update handlers
  const handleCreated = (newItem: SystemMessage) => {
    setData(prev => [...prev, { ...newItem, createdOn: new Date() }]);
  };

  const handleUpdated = (updatedItem: SystemMessage) => {
    setData(prev => 
      prev.map(item => 
        item.id === updatedItem.id ? { ...item, ...updatedItem } : item
      )
    );
  };

  const handleDeleted = (deletedItem: SystemMessage) => {
    setData(prev => prev.filter(item => item.id !== deletedItem.id));
  };

  // Column definitions
  const columns: ColumnDef<SystemMessage>[] = [
    {
      accessorKey: "message",
      header: "Message",
      cell: ({ row }) => (
        <EditSystemMessage item={row.original} onUpdated={handleUpdated} />
      ),
    },
    {
      accessorKey: "localeId",
      header: ({ column }) => (
        <DataTableColumnHeader column={column} title="Locale" />
      ),
    },
    {
      accessorKey: "published",
      header: ({ column }) => (
        <DataTableColumnHeader column={column} title="Published" />
      ),
    },
    {
      id: "actions",
      cell: ({ row }) => (
        <CellAction item={row.original} onDeleted={handleDeleted} />
      ),
    },
  ];

  return (
    <>
      <div className="flex items-center justify-between">
        <Heading
          title="System Messages"
          badge={data.length}
          description="Manage system messages"
        />
        <EditSystemMessage item={newMessage} onUpdated={handleCreated} />
      </div>
      <Separator />
      <DataTable columns={columns} data={data} />
    </>
  );
};

// Cell action component with delete
interface CellActionProps {
  item: SystemMessage;
  onDeleted?: (item: SystemMessage) => void;
}

const CellAction: React.FC<CellActionProps> = ({ item, onDeleted }) => {
  const [loading, setLoading] = useState(false);
  const [open, setOpen] = useState(false);

  const onConfirm = async () => {
    try {
      setLoading(true);
      const response = await fetch(`/api/sysmsg/${item.id}`, {
        method: "DELETE",
      });
      
      if (!response.ok) throw new Error("Failed to delete");
      
      toast({ title: "Success", description: "Item deleted" });
      onDeleted?.(item);
    } catch (error) {
      toast({ variant: "destructive", title: "Error", description: "Something went wrong" });
    } finally {
      setLoading(false);
      setOpen(false);
    }
  };

  return (
    <>
      <AlertModal
        isOpen={open}
        onClose={() => setOpen(false)}
        onConfirm={onConfirm}
        loading={loading}
      />
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" className="size-8 p-0">
            <IconDots className="size-4" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuLabel>Actions</DropdownMenuLabel>
          <DropdownMenuItem onClick={() => navigator.clipboard.writeText(item.id)}>
            <IconCopy className="mr-2 size-4" /> Copy ID
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => setOpen(true)}>
            <IconTrash className="mr-2 size-4" /> Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </>
  );
};
```

### 5. Edit/Create Component

File: `components/edit-[object].tsx`

```tsx
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { toast } from "@/components/ui/use-toast";
import { IconPlus } from "@tabler/icons-react";
import { updateSystemMessageAction } from "@/actions/sysAdmin/systemMessage/update-system-message";
import {
  type UpdateSystemMessageInput,
  updateSystemMessageSchema,
} from "@/actions/sysAdmin/systemMessage/update-system-message.validation";
import type { SystemMessage } from "@/types";

interface Props {
  item: UpdateSystemMessageInput;
  onUpdated?: (newValue: UpdateSystemMessageInput) => void;
}

export const EditSystemMessage: React.FC<Props> = ({ item, onUpdated }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [loading, setLoading] = useState(false);

  const isNew = item.id === "new";

  const form = useForm<UpdateSystemMessageInput>({
    resolver: zodResolver(updateSystemMessageSchema),
    defaultValues: item,
    mode: "onChange",
  });

  async function onSubmit(data: UpdateSystemMessageInput) {
    setLoading(true);
    
    const result = await updateSystemMessageAction(data);
    
    if (result?.serverError) {
      toastError({ description: result.serverError });
      setLoading(false);
      return;
    }

    // For create, get the new ID from server response
    if (isNew) {
      data.id = result.data.id;
      data.createdOn = result.data.createdOn;
      toast({ title: "Success", description: "Created successfully" });
    } else {
      toast({ title: "Success", description: "Updated successfully" });
    }

    setLoading(false);
    setIsOpen(false);
    
    // Update parent state
    onUpdated?.(data);
  }

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {isNew ? (
          <Button variant="outline">
            <IconPlus className="mr-2 size-4" />
            Create
          </Button>
        ) : (
          <Button variant="link" className="px-0 text-left">
            {item.message}
          </Button>
        )}
      </DialogTrigger>

      <DialogContent>
        <DialogHeader>
          <DialogTitle>
            {isNew ? "Create" : "Edit"} System Message
          </DialogTitle>
          <DialogDescription>
            Fill in the form below to {isNew ? "create" : "update"} the message.
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="message"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Message</FormLabel>
                  <FormControl>
                    <Textarea
                      disabled={loading}
                      placeholder="Enter message"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="localeId"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Locale</FormLabel>
                  <FormControl>
                    <Input disabled={loading} {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="published"
              render={({ field }) => (
                <FormItem className="flex items-center justify-between rounded-lg border p-3">
                  <FormLabel>Published</FormLabel>
                  <FormControl>
                    <Switch
                      checked={field.value}
                      onCheckedChange={field.onChange}
                    />
                  </FormControl>
                </FormItem>
              )}
            />

            <div className="flex gap-2">
              <Button type="submit" disabled={loading}>
                Submit
              </Button>
              <Button
                type="button"
                variant="outline"
                onClick={() => setIsOpen(false)}
              >
                Cancel
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};
```

### 6. Filter Implementation (Optional)

For complex lists, you may want to add filtering capabilities.

#### 6.1 Filter Component

```tsx
import { useState } from "react";
import {
  Popover,
  PopoverTrigger,
  PopoverContent,
  Button,
  Badge,
  Tabs,
  TabsList,
  TabsTrigger,
  TabsContent,
  Command,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  Input,
  cn,
} from "mingster.backbone";
import { IconCheck, IconFilter } from "@tabler/icons-react";

interface FilterProps {
  selectedStatuses: string[];
  onStatusChange: (statuses: string[]) => void;
  onTitleChange?: (title: string) => void;
  titleFilter?: string;
  className?: string;
}

export function FilterComponent({
  selectedStatuses,
  onStatusChange,
  onTitleChange,
  titleFilter = "",
  className,
}: FilterProps) {
  const [open, setOpen] = useState(false);
  const [activeTab, setActiveTab] = useState<"status" | "title">("status");
  
  const statuses = ["active", "inactive", "pending"];
  
  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button variant="outline" className={className}>
          <IconFilter className="mr-2 h-4 w-4" />
          Filter
          {selectedStatuses.length > 0 && (
            <Badge variant="secondary" className="ml-2">
              {selectedStatuses.length}
            </Badge>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-[300px] p-0">
        <Tabs 
          defaultValue="status" 
          value={activeTab} 
          onValueChange={(v) => setActiveTab(v as "status" | "title")}
        >
          <TabsList className="w-full">
            <TabsTrigger value="status" className="flex-1">
              Status
            </TabsTrigger>
            <TabsTrigger value="title" className="flex-1">
              Title
            </TabsTrigger>
          </TabsList>
          
          <TabsContent value="status" className="p-2">
            <Command>
              <CommandInput placeholder="Search status..." />
              <CommandList>
                <CommandEmpty>No status found.</CommandEmpty>
                <CommandGroup>
                  {statuses.map((status) => (
                    <CommandItem
                      key={status}
                      onSelect={() => {
                        onStatusChange(
                          selectedStatuses.includes(status)
                            ? selectedStatuses.filter((s) => s !== status)
                            : [...selectedStatuses, status]
                        );
                      }}
                    >
                      <IconCheck
                        className={cn(
                          "mr-2 h-4 w-4",
                          selectedStatuses.includes(status) 
                            ? "opacity-100" 
                            : "opacity-0"
                        )}
                      />
                      {status}
                    </CommandItem>
                  ))}
                </CommandGroup>
              </CommandList>
            </Command>
          </TabsContent>
          
          <TabsContent value="title" className="p-2">
            <Input
              placeholder="Search by title..."
              value={titleFilter}
              onChange={(e) => onTitleChange?.(e.target.value)}
            />
          </TabsContent>
        </Tabs>
      </PopoverContent>
    </Popover>
  );
}
```

#### 6.2 Using Filters in Client Component

```tsx
import { useMemo } from "react";

export const SystemMessageClient: React.FC<Props> = ({ serverData }) => {
  const [data, setData] = useState<SystemMessage[]>(serverData);
  const [selectedStatuses, setSelectedStatuses] = useState<string[]>([]);
  const [titleFilter, setTitleFilter] = useState("");

  // Apply filters
  const filteredData = useMemo(() => {
    return data.filter((item) => {
      const statusMatch = 
        selectedStatuses.length === 0 || 
        selectedStatuses.includes(item.status);
      
      const titleMatch = 
        !titleFilter || 
        item.title?.toLowerCase().includes(titleFilter.toLowerCase()) ||
        item.message?.toLowerCase().includes(titleFilter.toLowerCase());
      
      return statusMatch && titleMatch;
    });
  }, [data, selectedStatuses, titleFilter]);

  return (
    <>
      <div className="flex items-center justify-between">
        <Heading title="System Messages" badge={data.length} />
        <div className="flex gap-2">
          <FilterComponent
            selectedStatuses={selectedStatuses}
            onStatusChange={setSelectedStatuses}
            onTitleChange={setTitleFilter}
            titleFilter={titleFilter}
          />
          <EditSystemMessage item={newMessage} onUpdated={handleCreated} />
        </div>
      </div>
      <Separator />
      <DataTable columns={columns} data={filteredData} />
    </>
  );
};
```

## Key Imports

All UI components should come from local component directories:

```tsx
// Data Display
import { DataTable, DataTableColumnHeader } from "@/components/data-table";
import { Heading } from "@/components/heading";
import Container from "@/components/ui/container";
import { Separator } from "@/components/ui/separator";
import { Loader } from "@/components/loader";

// UI Components
import { Button } from "@/components/ui/button";
import { Dialog, DialogTrigger, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Select } from "@/components/ui/select";

// Actions
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
} from "@/components/ui/dropdown-menu";
import { AlertModal } from "@/components/modals/alert-modal";

// Toast
import { toast } from "@/components/ui/use-toast";

// Utilities
import { cn, transformBigIntToNumbers } from "@/lib/utils";
```

## Summary

- **Import UI locally**: All shadcn/ui components come from `@/components/ui/`
- **Local state management**: Hold data array in client component state
- **Callback pattern**: Pass mutation callbacks to edit/create/delete components
- **Direct state updates**: Update state array immediately after mutations
- **No router.refresh**: Don't rely on it for client state updates
- **Type safety**: Ensure all required fields are present when adding to state
- **Server components**: Fetch data on server, pass to client component
- **Server actions**: Use for all mutations (create, update, delete)

This pattern ensures a fast, reactive UI with consistent updates and avoids common pitfalls with stale or unsynced data.
